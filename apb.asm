; Apparat PROM Blaser for Apple II
; reverse-engineered by Eric Smith <spacewar@gmail.com>

	cpu	6502

origin	equ	$0803

keytab	macro	char,addr
	fdb	addr
	if	char
	fcb	char+$80
	else
	fcb	$00
	endif
	endm

prtmsg	macro	addr
	jsr	print_msg
	fdb	addr-1
	endm

prtmsgi	macro	addr
	jsr	print_msg_indexed
	fdb	addr-1
	endm

dinc	macro	addr
	inc	addr
	bne	no_carry
	inc	addr+1
no_carry:
	endm

ddec	macro	addr
	lda	addr
	bne	no_borrow
	dec	addr+1
no_borrow:
	dec	addr
	endm

; string with last character having MSB set
fcsm	macro	arg
	if	strlen(arg) > 1
	fcb	substr(arg,0,strlen(arg)-1)
	endif
	fcb	charfromstr(arg,strlen(arg)-1)+$80
	endm

; string terminated by CR with MSB set
fcs_cr	macro	arg
	fcb	arg,char_cr+$80
	endm


; APB hardware
pia_data	equ	$c080		; indexed by slot * 16
pia_ctrl	equ	$c081		; indexed by slot * 16

; PIA port A bits (all outputs)
pia_a_addr_inc	equ	$01	; CD4040 clock, counts on negative edge
pia_a_addr_rst	equ	$02	; CD4040 reset, active high
pia_a_ttl1	equ	$08

pia_a_ppl_mask	equ	$30
pia_a_ppl_gnd	equ	$00
pia_a_ppl_12V	equ	$20
pia_a_ppl_5V	equ	$30

pia_a_pph_mask	equ	$c0
pia_a_pph_gnd	equ	$00
pia_a_pph_5V	equ	$40
pia_a_pph_26V	equ	$80
pia_a_pph_open	equ	$c0

; PIA port B is PROM data bus (bidirectional)

; PIA control registers
; CA1, CA2, CB1, CB2, and interrupts are unused
pia_ctl_dir	equ	$00
pia_ctl_data	equ	$04


; characters
char_etx  	equ	$03	; control-C
char_bell 	equ	$07
char_bs	  	equ	$08
char_cr   	equ	$0d
char_dc3  	equ	$13	; control-S, flow control
char_right_arr	equ	$15	; control-U, right arrow
char_can  	equ	$18	; control-X, cancel

; Apple II monitor zero page
wndtop	equ	$22		; text window top edge
ch	equ	$24		; cursor column (zero-based)
cv	equ	$25		; cursor row (zero-based)
basl	equ	$28		; address of current text ROM
invflg	equ	$32
a1l	equ	$3c
a2l	equ	$3e
a4l	equ	$42

; Apple DOS vectors
dos_warm_start		equ	$03d0
dos_fm			equ	$03d6
rwts			equ	$03d9
fm_get_fcb		equ	$03dc	; into A:Y
rwts_get_iocb		equ	$03e3	; into A:Y

; RWTS param list offsets
iocb_type	equ	$00
iocb_slot_x16	equ	$01
iocb_drive	equ	$02
iocb_vol	equ	$03	; 0 matches any
iocb_track	equ	$04
iocb_sector	equ	$05
iocb_dct_ptr	equ	$06
iocb_buf	equ	$08
iocb_byte_count	equ	$0b	; 0 for entire sector
iocb_cmd	equ	$0c
iocb_ret_code	equ	$0d
iocb_last_vol	equ	$0e
iocb_last_slot	equ	$0f
iocb_last_drive	equ	$10

; RWTS commands
rwts_cmd_seek	equ	$00
rwts_cmd_read	equ	$01
rwts_cmd_write	equ	$02
rwts_cmd_format	equ	$04

; RWTS return codes
rwts_err_none	equ	$00
rtts_err_init	equ	$08
rwts_err_wprot	equ	$10
rwts_err_volnum	equ	$20
rwts_err_drive	equ	$40

; DOS File Manager param list offsets
;                           ; bits OCRWDCLURPIV
fcb_cmd		equ	$00 ; 8    ************
fcb_option	equ	$01 ; 8    ..**........
fcb_rec_len	equ	$02 ; 16   *...........  record length or 0
fcb_rec_num	equ	$02 ; 16   ..**.....*..  record number
fcb_new_name	equ	$02 ; 16   ........*...  new file name ptr
fcb_byte_off	equ	$04 ; 16   ..**.....*..  byte offset
fcb_vol		equ	$04 ; 8    *...*.***.**  volume number
fcb_drive	equ	$05 ; 8    *...*****.**  drive number
fcb_byte_count	equ     $06 ; 16   ..**........  byte count
fcb_slot	equ	$06 ; 8    *...*****.**  slot number
fcb_file_type	equ	$07 ; 8    *...........  file type
fcb_file_name	equ	$08 ; 16   *...*.***..*  file name
fcb_data_byte	equ	$08 ; 8    ..**........  one byte to xfer
fcb_data_ptr	equ	$08 ; 16   ..**........  pointer to data to xfer
fcb_ret_code	equ	$0a ; 8    ************ return code
fcb_work_area	equ	$0c ; 16   ************ work area
fcb_tsl_buf	equ	$0e ; 16   *****.***..* track/sector list buf
fcb_data_buf	equ	$10 ; 16   .***.......* data buffer

; DOS file manager commands
fm_cmd_open	equ	$01
fm_cmd_close	equ	$02
fm_cmd_read	equ	$03
fm_cmd_write	equ	$04
fm_cmd_delete	equ	$05
fm_cmd_catalog	equ	$06
fm_cmd_lock	equ	$07
fm_cmd_unlock	equ	$08
fm_cmd_rename	equ	$09
fm_cmd_position	equ	$0a
fm_cmd_init	equ	$0b
fm_cmd_verify	equ	$0c

; DOS file manager options (for read and write commands)
fm_opt_noop	equ	$00
fm_opt_one	equ	$01
fm_opt_rng	equ	$02
fm_opt_pos_one	equ	$03
fm_opt_pos_rng	equ	$04

; DOS error codes - not all are generated by file manager
dos_err_none		equ	$00
dos_err_lang_not_avail	equ	$01
dos_err_bad_cmd		equ	$02
dos_err_bad_oot		equ	$03
dos_err_wprot		equ	$04
dos_err_end		equ	$05
dos_err_not_fnd		equ	$06
dos_err_vol		equ	$07
dos_err_io		equ	$08
dos_err_full		equ	$09
dos_err_locked		equ	$0a
dos_err_syntax		equ	$0b
dos_err_no_buf		equ	$0c
dos_err_file_type	equ	$0d
dos_err_prog_too_large	equ	$0e
dos_err_not_direct_cmd	equ	$0f

; DOS file types
file_type_text	equ	$00
file_type_int	equ	$01
file_type_fp    equ	$02
file_type_bin   equ	$04
file_type_s	equ	$08
file_type_rel	equ	$10

; TSL sector
tsl_next_trk	equ	$01
tsl_next_sect	equ	$02
tsl_sect_offset	equ	$05
tsl_first_entry	equ	$0c

; Apple II monitor vectors
softev	equ	$03f2	; reset
usraddr	equ	$03f8	; control-Y from monitor

; Apple II hardware
kbd	equ	$c000
kbdstrb	equ	$c010
spkr	equ	$c030

; Apple II monitor entry points
prntax	equ	$f941
init	equ	$fb2f
vtab	equ	$fc22
home	equ	$fc58
wait	equ	$fca8
crout	equ	$fd8e
prbyte	equ	$fdda
prhex	equ	$fde3
cout	equ	$fded
move	equ	$fe2c
setnorm	equ	$fe84
setkbd	equ	$fe89
setvid	equ	$fe93
mon	equ	$ff65
monz	equ	$ff69


; zero page
	org	$0000
Z00	rmb	2
Z02	rmb	2
Z04	rmb	2
Z06	rmb	2
Z08	rmb	2
Z0a	rmb	2
Z0c	rmb	2
Z0e	rmb	1
Z0f	rmb	2
Z11	rmb	1
Z12	rmb	1
Z13	rmb	1		; disk slot (not multiplied by 16)
Z14	rmb	1		; disk drive
fcb	rmb	2
Z17	rmb	2
Z19	rmb	1


	org	$3d80
; These buffers for dealing with the file manager should be
; in RAM just after the program, rather than just under the
; user data buffer.

b_filename	rmb	30
b_work_area	rmb	45
b_tsl_buf	rmb	256
b_data_buf	rmb	256

ram_buf	equ	$4000




	org	origin

; ---------- START OF FAST LOADER ----------

L0803:	jsr	fm_get_fcb	; get file manager param list addr in A:Y
	sty	Z00		; store into Z00
	sta	Z00+1

	ldy	#fcb_tsl_buf	; get address of TSL from param list into Z00
	lda	(Z00),Y
	pha
	iny
	lda	(Z00),Y
	sta	Z00+1
	pla
	sta	Z00

	jsr	rwts_get_iocb	; get RWTS IOCB into Z02
	sty	Z02
	sta	Z02+1

	ldy	#iocb_vol	; set RWTS vol number to 0
	lda	#$00
	sta	(Z02),Y

	ldy	#iocb_cmd	; set RWTS command code to READ
	lda	#$01
	sta	(Z02),Y

	ldy	#iocb_buf	; set buffer to $08ff
	lda	#$ff
	sta	(Z02),Y
	iny
	lda	#$08
	sta	(Z02),Y

	ldx	#tsl_first_entry+2	; skip the first TSL entry, first sector already loaded

load_sector:
	txa
	tay
	lda	(Z00),Y		; get track number
	beq	loader_done	; if zero, done loading
	ldy	#iocb_track	; store as RWTS track
	sta	(Z02),Y
	txa
	tay
	iny
	lda	(Z00),Y		; get sector number
	ldy	#iocb_sector	; store as RWTS sector
	sta	(Z02),Y
	txa
	pha
	jsr	rwts_get_iocb	; get RWTS IOCB
	jsr	rwts		; call RWTS
	bcs	loader_error	; carry set if error
	pla
	tax
	inx
	inx
	ldy	#$09		; advance RWTS buffer by 256 bytes
	lda	(Z02),Y
	clc
	adc	#$01
	sta	(Z02),Y
	bne	load_sector	; go read next sector (branch should always be taken)

; output loader error message
loader_error:
	lda	#$12
	sta	Z11
loader_error_1:
	ldx	Z11
	lda	load_err_msg-1,X
	jsr	cout
	dec	Z11
	bne	loader_error_1

	jmp	dos_warm_start	; exit to DOS/BASIC

; in reverse order, <CR><BELL>APB BOOT ERROR<CR><CR>
load_err_msg:
	fcb	char_cr+$80,char_cr+$80
	fcb	$d2,$cf,$d2,$d2,$c5,$a0
	fcb	$d4,$cf,$cf,$c2,$a0,$c2,$d0,$c1
	fcb	char_bell+$80,char_cr+$80

loader_done:
; ---------- END OF FAST LOADER ----------

	jsr	fm_get_fcb	; get file control block into fcb
	sty	fcb
	sta	fcb+1

	ldy	#$0c		; get file manager work area into Z00
	lda	(fcb),Y
	sta	Z00
	iny
	lda	(fcb),Y
	sta	Z00+1

	ldy	#$26		; get slot and drive into Z13 and Z14
	lda	(Z00),Y
	lsr
	lsr
	lsr
	lsr
	sta	Z13
	iny
	lda	(Z00),Y
	sta	Z14

	cld			; kinda late to be doing this

; set edit buffer pointer
	lda	#ram_buf&$ff
	sta	Z0f
	lda	#ram_buf>>8
	sta	Z0f+1

; set monitor control-Y vector to reinit
	lda	#$4c
	sta	usraddr
	lda	#reinit&$ff
	sta	usraddr+1
	lda	#reinit>>8
	sta	usraddr+2

; set reset vector to FF65 (monitor entry)
	lda	#mon&$ff
	sta	softev
	lda	#mon>>8
	sta	softev+1
	eor	#$a5
	sta	softev+2

reinit:
; NOTE: should probably reset stack pointer here,
; because error handler jump here without returning
; from subroutine.
	jsr	pia_init

	jsr	setvid
	jsr	setkbd
	jsr	init
	jsr	setnorm
	jsr	home
	prtmsg	msg_banner

	prtmsg	msg_slot	; display APB slot
	lda	apb_slot_x16
	lsr
	lsr
	lsr
	lsr
	jsr	prhex

	prtmsg	msg_prom_colon	; display selected PROM type

	ldy	prom_type
	prtmsgi	msg_prom_name_table

	jsr	crout
	lda	cv
	sta	wndtop

main:	jsr	home
	prtmsg	msg_main_menu

get_cmd:
	jsr	get_key_dispatch

	keytab	'A',cmd_apb_slot
	keytab	'P',cmd_prom_type
	keytab	'C',cmd_chk_erase
	keytab	'R',cmd_read_prom
	keytab	'B',cmd_blast_prom
	keytab	'V',cmd_verify_prom
	keytab	'L',cmd_disk_load
	keytab	'S',cmd_disk_save
	keytab	'U',cmd_update_prog
	keytab	'E',cmd_edit_buffer
	keytab	'M',cmd_move_memory
	keytab	'F',cmd_fill_memory
	keytab	'Q',cmd_quit
	keytab	$00,get_cmd


cmd_apb_slot:
	jsr	home
	prtmsg	msg_enter_apb_slot

L0947:	jsr	get_key_dispatch

	keytab	char_cr,main
	keytab	$00,L0950

L0950:	cmp	#$08		; number in [0, 7]?
	bcs	L0947		;   no, try again
	asl			; yes, mult by 16
	asl
	asl
	asl
L0958:	sta	apb_slot_x16
	jmp	reinit


cmd_prom_type:
	jsr	home
	lda	#$00
	sta	Z04
L0965:	lda	Z04
	jsr	prhex
	prtmsg	msg_right_paren_sp_sp
	ldy	Z04
	prtmsgi	msg_prom_name_table

	inc	Z04
	lda	Z04
	cmp	#$0a	; max PROM index
	bcc	L0965
	prtmsg	msg_enter_prom_type
L0983:	jsr	get_key_dispatch
	keytab	char_cr,main
	keytab	$00,L098c

L098c:	cmp	#$0a
	bcs	L0983
	sta	prom_type
	jmp	reinit


cmd_quit:
	jsr	init
	jsr	home
	jmp	monz


cmd_chk_erase:
	jsr	home
	ldx	prom_type
	lda	prom_tbl_config_erase,X
	beq	L09cf
	prtmsg	msg_erase_eeprom
	jsr	S124c
	bcs	L09cf
	ldx	prom_type
	lda	prom_tbl_config_prog_pulse_end,X
	jsr	write_pia_data_reg_a
	jsr	set_prom_data_output
	lda	prom_tbl_config_erase,X
	jsr	write_pia_data_reg_a
	lda	prom_tbl_prog_pulse_time,X
	jsr	wait
	jsr	pia_init

L09cf:	jsr	S104b
	jsr	set_prom_data_input
	lda	prom_tbl_config_read,X
	jsr	write_pia_data_reg_a
	lda	#$00
	sta	Z11
L09df:	lda	#$ff
	jsr	S0b1d
	bcc	L0a05
	lda	#$01
	sta	Z11
	lda	kbd
	bpl	L0a05
	bit	kbdstrb
	cmp	#char_dc3+$80
	bne	L0a01
L09f6:	bit	kbd
	bpl	L09f6
	bit	kbdstrb
	jmp	L0a05
L0a01:	inc	Z11
	bne	L0a0a
L0a05:	jsr	inc_prom_addr
	bcc	L09df
L0a0a:	jsr	pia_init
	ldy	Z11
	prtmsgi	msg_prom_erase_status
	jsr	press_any_key
	jmp	main


cmd_read_prom:
	prtmsg	msg_reading_prom
	ldx	prom_type
	jsr	S104b
	jsr	set_prom_data_input
	lda	prom_tbl_config_read,X
	jsr	write_pia_data_reg_a
L0a2e:	jsr	read_pia_data_reg_b
	ldy	#$00
	sta	(Z06),Y
	jsr	inc_prom_addr
	bcc	L0a2e
	jsr	pia_init
L0a3d:	jmp	main


cmd_blast_prom:
	jsr	home
	prtmsg	msg_blast_prom
	jsr	S124c
	bcs	L0a3d
	ldx	prom_type
	jsr	S104b
	jsr	set_prom_data_input
	lda	prom_tbl_config_read,X
	jsr	write_pia_data_reg_a
L0a5c:	jsr	read_pia_data_reg_b
	cmp	#$ff
	bne	L0a6a
	jsr	inc_prom_addr
	bcc	L0a5c
	bcs	L0a7c
L0a6a:	jsr	pia_init
	prtmsg	msg_prom_not_erased
	prtmsg	msg_proceed
	jsr	S124c
	bcs	L0a3d
L0a7c:	prtmsg	msg_blasting_prom
	ldx	prom_type
	lda	prom_tbl_prog_pulse_count,x
	sta	z11
	lda	prom_tbl_config_prog_pulse_end,x
	jsr	write_pia_data_reg_a
	jsr	set_prom_data_output
L0a92:	jsr	S104b
	lda	Z11
	jsr	prbyte
	prtmsg	msg_bs_bs
	ldx	prom_type
L0aa2:	ldy	#$00
	lda	(Z06),Y
	jsr	write_pia_data_reg_b
	lda	prom_tbl_config_prog_pulse_start,X
	ora	Z19
	jsr	write_pia_data_reg_a
	lda	prom_tbl_prog_pulse_time,X
	jsr	wait
	lda	prom_tbl_config_prog_pulse_end,X
	ora	Z19
	jsr	write_pia_data_reg_a
	jsr	inc_prom_addr
	bcc	L0aa2
	dec	Z11
	bne	L0a92

cmd_verify_prom:
	prtmsg	msg_verifying

	ldx	prom_type
	jsr	S104b
	jsr	set_prom_data_input
	lda	prom_tbl_config_read,X
	jsr	write_pia_data_reg_a
	lda	#$00
	sta	Z11
L0ae0:	ldy	#$00
	lda	(Z06),Y
	jsr	S0b1d
	bcc	L0b08
	lda	#$01
	sta	Z11
	lda	kbd
	bpl	L0b08
	bit	kbdstrb
	cmp	#char_dc3+$80
	bne	L0b04
L0af9:	bit	kbd
	bpl	L0af9
	bit	kbdstrb
	jmp	L0b08
L0b04:	inc	Z11
	bne	L0b0d		; always taken

L0b08:	jsr	inc_prom_addr
	bcc	L0ae0
L0b0d:	jsr	pia_init
	ldy	Z11
	prtmsgi	msg_prom_verify_status
	jsr	press_any_key
	jmp	main

S0b1d:	sta	Z08
	jsr	read_pia_data_reg_b
	cmp	Z08
	bne	L0b28
	clc
	rts
L0b28:	pha
	prtmsg	msg_prom_verify_addr
	ldx	Z17
	lda	Z17+1
	jsr	prntax
	prtmsg	msg_prom_verify_expected
	lda	Z08
	jsr	prbyte
	prtmsg  msg_prom_verify_found
	pla
	jsr	prbyte
	ldx	prom_type
	sec
	rts


cmd_edit_buffer:
	jsr	home
L0b50:	lda	#$01
	sta	Z11
L0b54:	jsr	S0c1d
	jsr	get_key_dispatch
	keytab	'I',L0bc1
	keytab	'J',L0b9f
	keytab	'K',L0b93
	keytab	'M',L0bb0
	keytab	char_bs,L0bd5
	keytab	char_right_arr,L0be0
	keytab	$02,L0beb
	keytab	$05,L0bf6
	keytab	'G',L0c01
	keytab	'R',main
	keytab	$00,L0b7b

L0b7b:	asl
	asl
	asl
	asl
	sta	Z00
	ldy	#$00
	lda	(Z0f),Y
	ldx	#$03
L0b87:	asl	Z00
	rol
	dex
	bpl	L0b87
	sta	(Z0f),Y
	dec	Z11
	bpl	L0b54

L0b93:	dinc	Z0f
	lda	Z0f+1
	cmp	#$60
	bcc	L0bad

L0b9f:	ddec	Z0f
	lda	Z0f+1
	cmp	#$40
	bcc	L0b93
L0bad:	jmp	L0b50

L0bb0:	clc
	lda	Z0f
	adc	#$10
	sta	Z0f
	bcc	L0bd2
	inc	Z0f+1
	lda	Z0f+1
	cmp	#$60
	bcc	L0bd2

L0bc1:	sec
	lda	Z0f
	sbc	#$10
	sta	Z0f
	bcs	L0bd2
	dec	Z0f+1
	lda	Z0f+1
	cmp	#$40
	bcc	L0bb0
L0bd2:	jmp	L0b50

L0bd5:	lda	Z0f+1
	cmp	#$40
	beq	L0bdd
	dec	Z0f+1
L0bdd:	jmp	L0b50

L0be0:	lda	Z0f+1
	cmp	#$5f
	beq	L0be8
	inc	Z0f+1
L0be8:	jmp	L0b50

L0beb:	lda	#$00
	sta	Z0f
	lda	#$40
	sta	Z0f+1
	jmp	L0b50

L0bf6:	lda	#$ff
	sta	Z0f
	lda	#$5f
	sta	Z0f+1
	jmp	L0b50

L0c01:	prtmsg	msg_new_cursor_offset
	clc
	jsr	S11bc
	beq	L0c1a
	lda	Z0a+1
	cmp	#$20
	bcs	L0c1a
	adc	#$40
	sta	Z0f+1
	lda	Z0a
	sta	Z0f
L0c1a:	jmp	cmd_edit_buffer


S0c1d:	lda	wndtop
	sta	cv
	jsr	vtab
	ldy	#$00
	sty	ch
	sty	Z00
	lda	Z0f+1
	sta	Z00+1
L0c2e:	lda	Z00+1
	and	#$1f
	jsr	prbyte
	tya
	jsr	prbyte
	lda	#':'+$80
L0c3b:	jsr	cout
L0c3e:	cpy	Z0f
	bne	L0c46
	lda	#$3f
	sta	invflg
L0c46:	lda	(Z00),Y
	jsr	prbyte
	lda	#$ff
	sta	invflg
	iny
	beq	L0c60
	tya
	and	#$0f
	beq	L0c2e
	and	#$03
	bne	L0c3e
	lda	#' '+$80
	jmp	L0c3b
L0c60:	rts


cmd_move_memory:
	jsr	home
	jsr	S115e
	beq	L0ca9
	lda	Z0a
	sta	a1l
	lda	Z0a+1
	sta	a1l+1
	jsr	S1170
	beq	L0ca9
	sec
	lda	Z0a
	sta	a2l
	sbc	a1l
	sta	Z06
	lda	Z0a+1
	sta	a2l+1
	sbc	a1l+1
	sta	Z06+1
	cmp	#$20
	bcs	L0cac
	jsr	S1117
	bcs	L0cac
	lda	Z0a
	sta	a4l
	lda	Z0a+1
	sta	a4l+1
	lda	a4l
	adc	Z06
	lda	a4l+1
	adc	Z06+1
	cmp	#$60
	bcs	L0cac
	ldy	#$00
	jsr	move
L0ca9:	jmp	main
L0cac:	prtmsg	msg_cmd_error
	jsr	press_any_key
	jmp	main


cmd_fill_memory:
	jsr	home
	jsr	S1117
	bcs	L0d2c
	lda	Z0a
	sta	a1l
	sta	a4l
	lda	Z0a+1
	sta	a1l+1
	sta	a4l+1
	jsr	S1127
	bcs	L0d2c
	sec
	lda	Z0a
	sta	a2l
	sbc	a1l
	lda	Z0a+1
	sta	a2l+1
	sbc	a1l+1
	bcc	L0d2c
	lda	#$00
	sta	Z06
	lda	#$00
	sta	Z06+1
	prtmsg	msg_enter_fill

L0cec:	prtmsg	msg_enter_rel_byte_number
	ldx	Z06
	lda	Z06+1
	jsr	prntax
	clc
	jsr	S11c0
	beq	L0d25
	ldy	#$00
	lda	Z0a
	sta	(a4l),Y
	dinc	Z06
	dinc	a4l

L0d10:	ddec	a2l

	sec
	lda	a2l
	sbc	a1l
	lda	a2l+1
	sbc	a1l+1
	bcs	L0cec
	bcc	L0d34

L0d25:	ldy	#$00
	jsr	move
	bcs	L0d34

L0d2c:	prtmsg	msg_cmd_error
	jsr	press_any_key
L0d34:	jmp	main


cmd_disk_load:
	jsr	init
	jsr	home
	jsr	S0f5d
	prtmsg	msg_file_to_load
	jsr	S128f
	bne	L0d4d
	jmp	L0df6

L0d4d:	lda	#$00
	ldy	#$04
L0d51	sta	(fcb),y
	dey
	bne	L0d51

	lda	#fm_cmd_open
	sta	(fcb),y

	ldy	#$07
	lda	#file_type_bin
	sta	(fcb),y

	ldx	#$ff
	jsr	call_file_manager

; read length from binary file header into Z0c (don't need start addr)

	ldy	#fcb_cmd
	lda	#fm_cmd_read
	sta	(fcb),Y
	iny

	lda	#fm_opt_pos_rng
	sta	(fcb),Y
	iny

	; record number: 0
	lda	#$00
	sta	(fcb),Y
	iny
	lda	#$00
	sta	(fcb),Y
	iny

	; byte offset: 2
	lda	#$02
	sta	(fcb),Y
	iny
	lda	#$00
	sta	(fcb),Y
	iny

	; length: 2
	lda	#$02
	sta	(fcb),Y
	iny
	lda	#$00
	sta	(fcb),Y
	iny

	; buffer addr
	lda	#Z0c&$ff
	sta	(fcb),Y
	iny
	lda	#Z0c>>8
	sta	(fcb),Y
	iny

	jsr	call_file_manager
	prtmsg	msg_enter_bytes_to_load
	sec
	jsr	S11bc
D0da5:	sec
	lda	Z0a
	sta	Z06
	sbc	Z0c
	sta	Z08
	lda	Z0a+1
	sta	Z06+1
	sbc	Z0c+1
	bcc	L0dba
	ora	Z08
	bne	L0df9
L0dba:	jsr	S1117
	bcs	L0df9
	lda	Z0a
	adc	Z06
	sta	Z08
	lda	Z0a+1
	adc	Z06+1
	cmp	#$60
	bcc	L0dd3
	bne	L0df9
	lda	Z08
	bne	L0df9

	; byte offset 4
L0dd3:	ldy	#fcb_byte_off
	lda	#$04
	sta	(fcb),Y
	iny
	lda	#$00
	sta	(fcb),Y
	iny

	; length from Z06
	lda	Z06
	sta	(fcb),Y
	iny
	lda	Z06+1
	sta	(fcb),Y
	iny

	; buffer addr from Z0a
	lda	Z0a
	sta	(fcb),Y
	iny
	lda	Z0a+1
	sta	(fcb),Y
	iny

	jsr	call_file_manager
L0df6:	jmp	reinit

L0df9:	prtmsg	msg_cmd_error
	jsr	press_any_key
L0e01:	jmp	reinit


cmd_disk_save:
	jsr	init
	jsr	home
	jsr	S0f5d
	prtmsg	msg_file_to_save
	jsr	S128f
	beq	L0e01

	lda	#$00
	ldy	#$04
L0e1b:	sta	(fcb),Y
	dey
	bne	L0e1b

	lda	#fm_cmd_open
	sta	(fcb),Y

	ldy	#fcb_file_type
	lda	#file_type_bin
	sta	(fcb),Y

	ldx	#$00
	jsr	call_file_manager
	jsr	S1117
	bcs	L0df9

	lda	Z0a
	sta	Z06
	lda	Z0a+1
	sta	Z06+1
	jsr	S1132
	bcs	L0df9

	sec
	lda	Z0a
	sbc	Z06
	sta	Z08
	lda	Z0a+1
	sbc	Z06+1
	sta	Z08+1
	bcc	L0df9
	dinc	Z08

	ldy	#fcb_cmd
	lda	#fm_cmd_write
	sta	(fcb),Y
	iny

	lda	#fm_opt_pos_rng
	sta	(fcb),Y
	iny

	; record number 0
	lda	#$00
	sta	(fcb),Y
	iny
	lda	#$00
	sta	(fcb),Y
	iny

	; byte offset 0
	lda	#$00
	sta	(fcb),Y
	iny
	lda	#$00
	sta	(fcb),Y
	iny

	; length 4 (write parameter is one less)
	lda	#$03
	sta	(fcb),Y
	iny
	lda	#$00
	sta	(fcb),Y
	iny

	; buffer address
	lda	#Z06&$ff
	sta	(fcb),Y
	iny
	lda	#Z06>>8
	sta	(fcb),Y
	iny

	jsr	call_file_manager

	; byte offset 4
	ldy	#fcb_byte_off
	lda	#$04
	sta	(fcb),Y
	iny
	lda	#$00
	sta	(fcb),Y
	iny

	; length (param must be one less)
	lda	Z08
	sta	(fcb),Y
	iny
	lda	Z08+1
	sta	(fcb),Y
	iny

	; buffer
	lda	Z06
	sta	(fcb),Y
	iny
	lda	Z06+1
	sta	(fcb),Y
	iny

	jsr	call_file_manager

	ldy	#fcb_cmd
	lda	#fm_cmd_close
	sta	(fcb),Y

	jsr	call_file_manager
L0eb9:	jmp	reinit


cmd_update_prog:
	jsr	init
	jsr	home
	jsr	S0f5d
	prtmsg	msg_file_to_update
	jsr	S128f
	beq	L0eb9

	lda	#$00
	ldy	#$04
L0ed3:	sta	(fcb),Y
	dey
	bne	L0ed3

	lda	#fm_cmd_open
	sta	(fcb),Y

	ldy	#fcb_file_type
	lda	#$04
	sta	(fcb),Y

	ldx	#$00
	jsr	call_file_manager

	lda	#origin&$ff
	sta	Z06
	lda	#origin>>8
	sta	Z06+1

	lda	#$fc
	sta	Z08
	lda	#$00
	sta	Z08+1

	ldy	#$00
	lda	#fm_cmd_write
	sta	(fcb),Y
	iny

	lda	#fm_opt_pos_rng
	sta	(fcb),Y
	iny

	; record number 0
	lda	#$00
	sta	(fcb),Y
	iny
	lda	#$00
	sta	(fcb),Y
	iny

	; byte offset 0
	lda	#$00
	sta	(fcb),Y
	iny
	lda	#$00
	sta	(fcb),Y
	iny

	; range length  4 (for write, parameter is one less than length)
	lda	#$03
	sta	(fcb),Y
	iny
	lda	#$00
	sta	(fcb),Y
	iny

	; buffer address
	lda	#Z06&$ff
	sta	(fcb),Y
	iny
	lda	#Z06>>8
	sta	(fcb),Y
	iny

	jsr	call_file_manager

; NOTE: should be able to continue from position, with fm_opt_rng
; rather than repositioning by keeping fm_opt_pos_rng
; byte offset: 4
	ldy	#fcb_byte_off
	lda	#$04
	sta	(fcb),Y
	iny
	lda	#$00
	sta	(fcb),Y
	iny

; byte count: program length (for write, one less)
	lda	#((prog_end-origin)-1)&$ff
	sta	(fcb),Y
	iny
	lda	#((prog_end-origin)-1)>>8
	sta	(fcb),Y
	iny

; buffer address: program start address
	lda	#origin&$ff
	sta	(fcb),Y
	iny
	lda	#origin>>8
	sta	(fcb),Y
	iny

	jsr	call_file_manager

	ldy	#fcb_cmd
	lda	#fm_cmd_close
	sta	(fcb),Y
	jsr	call_file_manager

	jmp	reinit


; NOTE: This is terrible! We're taking a DOS FCB,
; and pointing it at our own buffers. We should just
; use our own FCB, instead of using one from DOS!!!
S0f5d:	jsr	fm_get_fcb
	sty	fcb
	sta	fcb+1

	ldy	#fcb_file_name
	lda	#b_filename&$ff
	sta	(fcb),Y
	iny
	lda	#b_filename>>8
	sta	(fcb),Y
	iny

	ldy	#fcb_work_area
	lda	#b_work_area&$ff
	sta	(fcb),Y
	iny
	lda	#b_work_area>>8
	sta	(fcb),Y
	iny

	; fcb tsl buf
	lda	#b_tsl_buf&$ff
	sta	(fcb),Y
	iny
	lda	#b_tsl_buf>>8
	sta	(fcb),Y
	iny

	; fcb data buf
	lda	#b_data_buf&$ff
	sta	(fcb),Y
	iny
	lda	#b_data_buf>>8
	sta	(fcb),Y
	iny

	prtmsg	msg_disk_slot_number

	lda	Z13
	jsr	prhex

	prtmsg	msg_right_paren_question

L0f9f:	jsr	get_key_dispatch
	keytab	char_cr,L0fb3
	keytab	$00,L0fa8

L0fa8:	beq	L0f9f

	cmp	#char_bs
	bcs	L0f9f
	sta	Z13
	jsr	prhex
L0fb3:	jsr	crout
	ldy	#fcb_slot
	lda	Z13
	sta	(fcb),Y
	prtmsg	msg_disk_drive_number
	lda	Z14
	jsr	prhex
	prtmsg	msg_right_paren_question

L0fcb:	jsr	get_key_dispatch
	keytab	char_cr,L0fdf
	keytab	$00,L0fd4

L0fd4:	beq	L0fcb
	cmp	#char_etx
	bcs	L0fcb
	sta	Z14
	jsr	prhex
L0fdf:	ldy	#fcb_drive
	lda	Z14
	sta	(fcb),Y
	ldy	#fcb_cmd
	lda	#fm_cmd_catalog
	sta	(fcb),y
	jsr	call_file_manager
	jmp	crout


; write A to PIA direction register A
; destroys Y
write_pia_dir_a:
	clc
	fcb	$b0

; write A to PIA direction register B
; destroys Y
write_pia_dir_b:
	sec
	pha
	ldy	apb_slot_x16
	bcc	L0ffc
	iny
	iny
L0ffc:	lda	pia_ctrl,Y
	and	#$fb		; set direction reg access
	sta	pia_ctrl,Y
	pla
	sta	pia_data,Y
	rts


; read PIA peripheral register A
; destroys Y
read_pia_data_reg_a:
	clc
	fcb	$b0		; bcs opcode

; read PIA peripheral register B
; destroys Y
read_pia_data_reg_b:
	sec
	ldy	apb_slot_x16
	bcc	L1013
	iny
	iny
L1013:	lda	pia_ctrl,Y
	ora	#$04		; enable data register access (vs direction register)
	sta	pia_ctrl,Y
	lda	pia_data,Y
	rts


; write A to PIA peripheral register A
; destroys Y
write_pia_data_reg_a:
	clc
	fcb	$b0		; bcs opcode

; write A to PIA peripheral register B
; destroys Y
write_pia_data_reg_b:
	sec
	pha
	ldy	apb_slot_x16
	bcc	L102a
	iny
	iny
L102a:	lda	pia_ctrl,Y
	ora	#pia_ctl_data	; enable data register access (vs direction register) ; XXX why did dis6502 not disassemble this properly?
	sta	pia_ctrl,Y
	pla
	sta	pia_data,Y
	rts


; set PROM data bus to input (PROM to APB)
set_prom_data_input:
	lda	#$00
	jmp	write_pia_dir_b


; set PROM data bus to output (APB to PROM)
set_prom_data_output:
	lda	#$ff
	jmp	write_pia_dir_b


pia_init:
	lda	#$f9
	jsr	write_pia_data_reg_a
	lda	#$ff
	jmp	write_pia_dir_a


S104b:	lda	#$00
	sta	Z17
	lda	#$00
	sta	Z17+1
	lda	#$00
	sta	Z06
	lda	#$40
	sta	Z06+1
	lda	#$00
	sta	Z19

; !!!BUG!!! The ORA should set both reset (level
; sensitive) and increment (negative edge triggered). The AND
; should clear only the reset.
; As written, this usually works, but not always.
	jsr	read_pia_data_reg_a
	ora	#pia_a_addr_rst
	jsr	write_pia_data_reg_a
	and	#$fc			; BUG!!!
	jmp	write_pia_data_reg_a


; on return:
;   carry set: end of PROM
inc_prom_addr:
	dinc	Z17
	dinc	Z06
	lda	Z17+1
	cmp	prom_tbl_size,X
	bcs	L109d

	cmp	#$10		; address $1000 or more?
	bcc	L108f		; no

	jsr	read_pia_data_reg_a	; yes, set TTL1
	ora	#pia_a_ttl1
	jsr	write_pia_data_reg_a

	lda	#$08
	sta	Z19

; increment the low twelve bits of the PROM address
L108f:	jsr	read_pia_data_reg_a
	ora	#pia_a_addr_inc
	jsr	write_pia_data_reg_a
	and	#pia_a_addr_inc!$ff	; Macro Assembler AS - ! is XOR
	jsr	write_pia_data_reg_a
	clc
L109d:	rts


; output a message at the address pointed to by an inline
; parameter word
print_msg:
	ldy	#$00		; skip 0 messages

; output message #Y in a message list at the address pointed to
; by an inline parameter word
print_msg_indexed:
	pla			; get return address into Z00
	sta	Z00
	pla
	sta	Z00+1

	jsr	inc_get_Z00	; get message address into Z02
	sta	Z02
	jsr	inc_get_Z00
	sta	Z02+1

L10b0:	dey			; need to skip messages?
	bmi	L10ba		;   go, start output

; skip a message
L10b3:	jsr	inc_get_Z02	; get next character
	bpl	L10b3		; if LSB 0, still skipping same message
	bmi	L10b0		; otherwise, decrement skip count

L10ba:	jsr	inc_get_Z02	; get next character
	pha			; save for later LSB check
	ora	#$80		; set MSB to make "normal"
	jsr	cout		; output to screen
	pla			; get original charcter back
	bpl	L10ba		; if MSB clear, loop

	lda	Z00+1		; push updated return address
	pha
	lda	Z00
	pha
	rts			; and return


inc_get_Z00:
	ldx	#$00
	beq	L10d3

inc_get_Z02:
	ldx	#$02
L10d3:	inc	Z00,x
	bne	L10d9
	inc	Z00+1,x
L10d9:	lda	(Z00,x)
	rts


get_key_dispatch:
	pla
	sta	Z02
	pla
	sta	Z02+1
L10e2:	jsr	get_key_flash
	sta	Z0e
	lda	Z02
	sta	Z00
	lda	Z02+1
	sta	Z00+1
L10ef:	jsr	inc_get_Z00	; get dispatch address into Z04
	sta	Z04
	jsr	inc_get_Z00
	sta	Z04+1
	jsr	inc_get_Z00	; get dispatch character
	beq	L1105		; if zero, end of table, always taken
	cmp	Z0e		; does character match
	bne	L10ef		;   no, continue search
L1102:	jmp	(Z04)		; yes, go do it

L1105:	lda	Z0e		; is the charactar a hex digit?
	eor	#$b0
	cmp	#$0a
	bcc	L1113
	adc	#$88
	cmp	#$fa
	bcc	L10e2
L1113:	and	#$0f
	bpl	L1102		; always taken


S1117:	lda	#$00
	sta	Z0c
	lda	#$00
	sta	Z0c+1
	prtmsg	msg_first
	jmp	L1145

S1127:	lda	#$ff
	sta	Z0c
	lda	#$1f
	sta	Z0c+1
	jmp	L1140

S1132:	ldx	prom_type
	lda	#$ff
	sta	Z0c
	lda	prom_tbl_size,x
	sta	Z0c+1
	dec	Z0c+1

L1140:	prtmsg	msg_last
L1145:	prtmsg	msg_buffer
	prtmsg	msg_offset
	sec
	jsr	S11bc
	lda	Z0a+1
	cmp	#$20
	bcs	L115d
	adc	#$40
	sta	Z0a+1
L115d:	rts


S115e:	prtmsg	msg_first
	prtmsg	msg_memory
	prtmsg	msg_address
	clc
	bcc	S11bc


S1170:	prtmsg	msg_last
	prtmsg	msg_memory
	prtmsg	msg_address
	clc
	bcc	S11bc

L1182:	lda	#$00
	sta	Z0c
	lda	#$00
	sta	Z0c+1
	prtmsg	msg_first
	jmp	L11a5

; at 1192
	ldx	prom_type
	lda	#$ff
	sta	Z0c
	lda	prom_tbl_size,X
	sta	Z0c+1
	dec	Z0c+1
	prtmsg	msg_last

L11a5:	prtmsg	msg_prom
	prtmsg	msg_address
	sec
	jsr	S11bc
	ldx	prom_type
	lda	Z0a+1
	cmp	prom_tbl_size,X
	rts


S11bc:	lda	#$04
	bne	L11c2		; always taken

S11c0:	lda	#$02
L11c2:	sta	Z12
	bcc	L11d7
	prtmsg	msg_space_left_paren
	ldx	Z0c
	lda	Z0c+1
	jsr	prntax
	lda	#')'+$80
	jsr	cout
L11d7:	prtmsg	msg_question
L11dc:	lda	#$00
	sta	Z0a
	lda	#$00
	sta	Z0a+1
	sta	Z11
L11e6:	jsr	get_key_dispatch

	keytab	char_bs,L1213
	keytab  char_can,L122a
	keytab	char_cr,L123a
	keytab	$00,L11f5

L11f5:	ldx	Z11
	cpx	Z12
	bcs	L1210
	pha
	jsr	prhex
	pla
	asl
	asl
	asl
	asl
	ldx	#$03
L1206:	asl
	rol	Z0a
	rol	Z0a+1
	dex
	bpl	L1206
	inc	Z11
L1210:	jmp	L11e6

L1213:	lda	Z11
	beq	L1227
	prtmsg	msg_bs_space_bs

L121c:	ldx	#$03
L121e:	lsr	Z0a+1
	ror	Z0a
	dex
	bpl	L121e
	dec	Z11
L1227:	jmp	L11e6

L122a:	lda	Z11
	beq	L1237
L122e:	prtmsg	msg_bs_space_bs

L1233:	dec	Z11
	bne	L122e
L1237:	jmp	L11dc

L123a:	jsr	crout
	lda	Z11
	php
	bne	L124a
	lda	Z0c
	sta	Z0a
	lda	Z0c+1
	sta	Z0a+1
L124a:	plp
	rts

S124c:	prtmsg	msg_y_n
	jsr	get_key_flash
	cmp	#'Y'+$80
	beq	L125f
	lda	#'N'+$80
	jsr	cout
	sec
	rts

L125f:	lda	#'Y'+$80
	jsr	cout
	clc
	rts


press_any_key:
	prtmsg	msg_press_any_key

get_key_flash:
	ldy	ch
	lda	(basl),Y	; save character at cursor position
	pha

	and	#$3f		; change it to flash
	ora	#$40
	sta	(basl),Y

L1276:	ldx	kbd		; wait for key press
	bpl	L1276

	bit	kbdstrb		; clear key press

	bit	spkr		; make noize
	bit	spkr
	bit	spkr
	bit	spkr

	pla			; restore character at cursor position
	sta	(basl),Y

	txa			; transfer keyboard char to accumulator
	rts


S128f:	lda	#$1e
	sta	Z12
	lda	#$00
	sta	Z11
L1297:	jsr	get_key_flash
	cmp	#char_cr+$80
	beq	L12d2
	cmp	#char_bs+$80
	beq	L12b6
	cmp	#char_can+$80
	beq	L12c3
	ldx	Z11
	cpx	Z12
	bcs	L1297
	sta	b_filename,X
	jsr	cout
	inc	Z11
	bne	L1297
L12b6:	lda	Z11
	beq	L1297
	prtmsg	msg_bs_space_bs
	dec	Z11
	bpl	L1297
L12c3:	lda	Z11
	beq	L1297
L12c7:	prtmsg	msg_bs_space_bs
	dec	Z11
	bne	L12c7
	beq	L1297
L12d2:	jsr	crout
	ldy	Z11
	lda	#' '+$80
L12d9:	cpy	Z12
	bcs	L12e3
	sta	b_filename,Y
	iny
	bne	L12d9
L12e3:	lda	Z11
	rts


call_file_manager:
	jsr	dos_fm
	bcs	L1302		; if carry, go handle error

	ldy	#fcb_cmd	; was the comamnd open?
	lda	(fcb),Y
	cmp	#fm_cmd_open
	bne	L1301		;   no, all good

	ldy	#fcb_file_type	; is file type binary?
	lda	(fcb),Y
	and	#$7f
	cmp	#file_type_bin
	beq	L1301		;   yes, all good

	lda	#dos_err_file_type
	bne	L1306		; always taken

L1301:	rts

L1302:	ldy	#fcb_ret_code	; get FM error code
	lda	(fcb),Y

L1306:	pha
	prtmsg	msg_dos_error	; 0 is error intro msg
	pla
	tay
	prtmsgi	msg_dos_error
	jsr	press_any_key
	jmp	reinit


; PROM type tables

; PROM size in 256-byte pages
prom_tbl_size:
	fcb	$02,$04,$04,$08,$08,$10,$10,$20,$08,$08

; program pulse count
prom_tbl_prog_pulse_count:
	fcb	$67,$67,$01,$67,$01,$01,$01,$0c,$01,$01

; program pulse time - passed to Apple II monitor wait routine
; 2.5 n^2 + 13.5n + 13 machine cycles, average cycle time 0.980 us
; Many sources give an incorrect formula (wrong averagc cycle time), see
;     https://6502disassembly.com/a2-rom/
; These values were probably computed using the wrong formula.
prom_tbl_prog_pulse_time:
	fcb	$11,$11,$8b,$11,$8b,$8b,$8b,$19,$8b,$3c
; $11 =  17    945.6 us (2704, 2708, TMS2716)
; $19 =  25    1.875 ms (68764)
; $3c =  60    9.626 ms (2816)
; $8b = 139    49.18 ms (2508/2758, 2516/2716, 2532, 2732, 2815)

; manufacturer specs:
; Intel 2704, 2708, TI TMS2708, TMS2716  - pulses from 0.1 to 1.0 ms, total program time >100ms
; Intel 2716, 2758, 2732, 2732A - one 50 ms pulse,(max 55 ms)
; TI TMS2532 - one 50 ms pulse (max 55 ms)
; Motorola MCM68764 - pulse 2ms (AC characteristics), 6 to 25 pulses,
;                     if less than 25 and data reads valid, add 5
;                     additional pulses for margin
;                     fast prog algorithm: pulse 1ms, max 5 pulses, Vcc=6V
; Intel 2816 - one write pulse 10ms (min 9ms, max 15ms)
;              chip erase 10ms
;              APB hardware might not meet the programming
;              requirements (Vpp rise time), and definitely doesn't
;              meet the erase
;              requirements (/OE +9V to +15V))
;              (1981 Intel Component Data Catalog)
;              (1982 Intel Component Data Catalog)
; Intel 2815 - like 2816 but slower, 50 ms program pulse (max 80ms)
;              60 ms chip erase pulse
;              will need to compare for detaisl
;              (1982 Intel Component Data Catalog)

; read PIA A data
prom_tbl_config_read:
	fcb	$00,$00,$40,$30,$40,$40,$00,$00,$40,$40

; end program pulse PIA A data
prom_tbl_config_prog_pulse_end:
	fcb	$20,$20,$b0,$20,$b0,$b8,$b8,$40,$70,$70

; start program pulse PIA A data
prom_tbl_config_prog_pulse_start:
	fcb	$a0,$a0,$b8,$a0,$b8,$b0,$b0,$80,$b0,$b0

; erase EEPROM PIA A data, $00 if not an EEPROM
prom_tbl_config_erase:
	fcb	$00,$00,$00,$00,$00,$00,$00,$00,$a0,$a0


msg_banner:
	fcb	"     APPARAT PROM BLASTER SOFTWARE",char_cr
	fcb	"   VERSION 3.4 BY ERIC SMITH  6/2/82",char_cr
	fcb	"    COPYRIGHT (C) 1982 APPARAT, INC.",char_cr
	fcs_cr	"---------------------------------------"

msg_prom_colon:
	fcsm	"   PROM: "

msg_slot:
	fcsm	"APB SLOT: "

msg_main_menu:
	fcb	"         ***** MAIN MENU *****",char_cr,char_cr
	fcb	"A)  SELECT APB SLOT",char_cr
	fcb	"P)  SELECT PROM TYPE",char_cr
	fcb	"C)  CHECK ERASURE OR ERASE EEPROM",char_cr
	fcb	"R)  READ PROM INTO ARRAY",char_cr
	fcb	"B)  BLAST PROM FROM ARRAY",char_cr
	fcb	"V)  VERIFY PROM AGAINST ARRAY",char_cr
	fcb	"L)  LOAD DATA FROM DISK",char_cr
	fcb	"S)  SAVE DATA TO DISK",char_cr
	fcb	"E)  EDIT ARRAY",char_cr
	fcb	"M)  MOVE MEMORY INTO ARRAY", char_cr
	fcb	"F)  FILL ARRAY",char_cr
	fcb	"U)  UPDATE SOFTWARE TO DISK",char_cr
	fcb	"Q)  QUIT",char_cr
	fcb	char_cr
	fcsm	"SELECT FUNCTION: "

msg_enter_apb_slot:
	fcb	"ENTER APB CARD SLOT NUMBER OR PRESS",char_cr
	fcsm	"<RETURN> TO LEAVE UNCHANGED: "

msg_right_paren_sp_sp:
	fcsm	")  "

msg_enter_prom_type:
	fcb	char_cr,"ENTER THE NUMBER CORRESPONDING TO THE",char_cr
	fcb	"TYPE OF PROM YOU ARE USING, OR PRESS",char_cr
	fcsm	"<RETURN> TO LEAVE UNCHANGED: "

msg_first:
	fcsm	"FIRST "

msg_last:
	fcsm	"LAST "

msg_memory:
	fcsm	"MEMORY"

msg_buffer:
	fcsm	"BUFFER"

msg_prom:
	fcsm	"PROM"

msg_address:
	fcsm	" ADDRESS"

msg_offset:
	fcsm	" OFFSET"

msg_bs_space_bs:
	fcb	char_bs,' ',char_bs+$80

msg_space_left_paren:
	fcb	' ','('+$80

msg_right_paren_question:
	fcb	')'
msg_question:
	fcsm	"? "

msg_bs_bs:
	fcb	char_bs,char_bs+$80

msg_cmd_error:
	fcb	$0d,$07,"COMMAND ERROR!",char_cr+$80

msg_press_any_key:
	fcsm	"PRESS ANY KEY TO CONTINUE: "

msg_new_cursor_offset:
	fcsm	"NEW CURSOR OFFSET"

msg_disk_slot_number:
	fcsm	"DISK SLOT NUMBER ("

msg_disk_drive_number:
	fcsm	"DISK DRIVE NUMBER ("

msg_file_to_load:
	fcsm	"FILE TO LOAD? "

msg_file_to_save:
	fcsm	"FILE TO SAVE? "

msg_file_to_update:
	fcsm	"FILE TO UPDATE? "

msg_enter_fill:
	fcb	char_cr,"ENTER A SEQUENCE OF BYTES TO FILL",char_cr
	fcb	"MEMORY WITH, THEN PRESS <RETURN>.",char_cr
	fcb	char_cr+$80

msg_enter_rel_byte_number:
	fcsm	"ENTER RELATIVE BYTE NUMBER "

msg_enter_bytes_to_load:
	fcsm	"BYTES TO LOAD"

msg_y_n:
	fcsm	" (Y/N)? "

msg_prom_verify_addr:
	fcb	char_cr,"PROM ADDRESS",' '+$80

msg_prom_verify_expected:
	fcsm	": EXPECTED "

msg_prom_verify_found:
	fcsm	" FOUND "

msg_reading_prom:
	fcb	char_cr,"READING PROM...",' '+$80

msg_blast_prom:
	fcsm	"BLAST PROM"

msg_blasting_prom:
	fcb	char_cr, "BLASTING PROM... PASS",' '+$80

msg_proceed:
	fcsm	"PROCEED"

msg_erase_eeprom:
	fcsm	"ERASE EEPROM"

D17ab:	fcb	char_cr,"CHECKING ERASURE...",' '+$80

msg_prom_erase_status:
	fcb	char_cr,char_cr,"PROM ERASED.",char_cr+$80
msg_prom_not_erased:
	fcb	char_cr,char_cr,char_bell,"PROM NOT ERASED!",char_cr+$80
	fcb	char_cr,char_cr,char_bell,"ERASURE CHECK ABORTED!",char_cr+$80

msg_verifying:
	fcb	char_cr,"VERIFYING...",' '+$80

msg_prom_verify_status:
	fcb	char_cr,char_cr,"PROM VERIFIES O.K.",char_cr+$80
	fcb	char_cr,char_cr,char_bell,"PROM BAD!",char_cr+$80
	fcb	char_cr,char_cr,char_bell,"VERIFY ABORTED!",char_cr+$80

msg_prom_name_table:
	fcs_cr	"2704"
	fcs_cr	"2708"
	fcs_cr	"2508/2758"
	fcs_cr	"TMS2716-3 VOLTAGE"
	fcs_cr	"2516/I2716-5V ONLY"
	fcs_cr	"2532"
	fcs_cr	"2732(A)"
	fcs_cr	"68764"
	fcs_cr	"2815 EEPROM"
	fcs_cr	"2816 EEPROM"

msg_dos_error:
	fcb	$0d,$07,"DISK ERROR:",' '+$80
	fcs_cr	"LANGUAGE NOT AVAILABLE"
	fcs_cr	"RANGE ERROR (BAD FMGR OPCODE)"
	fcs_cr	"RANGE ERROR (BAD FMGR SUBCODE)"
	fcs_cr	"DISK WRITE PROTECTED"
	fcs_cr	"END OF FILE"
	fcs_cr	"FILE NOT FOUND"
	fcs_cr	"VOLUME MISMATCH"
	fcs_cr	"I/O ERROR"
	fcs_cr	"DISK FULL"
	fcs_cr	"FILE LOCKED"
	fcs_cr	"SYNTAX ERROR"
	fcs_cr	"NO BUFFERS AVAILABLE"
	fcs_cr	"FILE TYPE MISMATCH"
	fcs_cr	"PROGRAM TOO LARGE"
	fcs_cr	"NOT DIRECT COMMAND"

apb_slot_x16:
	fcb	$70

prom_type:
	fcb	$04

prog_end	equ	*

